import{_ as o,o as c,c as a,e as d}from"./app-63ba67c3.js";const l={};function n(i,e){return c(),a("div",null,[...e[0]||(e[0]=[d(`<h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> vue</h1><h2 id="_1、data-为什么是函数而不是对象" tabindex="-1"><a class="header-anchor" href="#_1、data-为什么是函数而不是对象" aria-hidden="true">#</a> 1、data 为什么是函数而不是对象</h2><ul><li>每个组件实例都应具有独立的数据。如果<code>data</code>属性是一个对象，那么它将成为所有组件实例之间共享的数据。这样一来，一个组件中的数据改变会影响到其他组件中的数据，导致意外的副作用。而将<code>data</code>属性设置为一个函数可以确保每个组件实例有自己的独立数据，避免了数据混用问题。</li><li>当组件被复用时，如果 data 属性是一个对象，那么每个组件实例之间会共享同一个数据对象。这意味着，如果一个组件实例改变了 data 对象中某个属性的初始值，那么它会影响到其他组件实例的初始值。而当 data 属性是一个函数时，每个组件实例都会调用该函数来获取一个新的数据对象，确保每个组件实例的数据都被正确地初始化。</li></ul><h2 id="_2、mixins-对于同名属性的处理" tabindex="-1"><a class="header-anchor" href="#_2、mixins-对于同名属性的处理" aria-hidden="true">#</a> 2、mixins 对于同名属性的处理</h2><ol><li>对于<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>的同名参数，页面上的会替代<code>mixins</code>中的</li><li><code>data</code>中的数据会进行深度合并</li><li>生命周期和<code>watch</code>则是会先执行<code>mixins</code>中的</li><li><code>component</code>、<code>directives</code>、<code>filters</code>会通过原型链层层叠加</li></ol><h2 id="_3、修饰符有哪些" tabindex="-1"><a class="header-anchor" href="#_3、修饰符有哪些" aria-hidden="true">#</a> 3、修饰符有哪些</h2><ol><li><p>表单修饰符</p><ul><li><code>lazy</code> 光标离开标签的时候才会触发值的修改</li><li><code>trim</code> 过滤首空格</li><li><code>number</code> 自动转为数值型，如果值无法被<code>parseFloat</code>解析则返回原值</li></ul></li><li><p>事件修饰符</p><ul><li><code>stop</code> 阻止事件冒泡</li><li><code>prevent</code> 阻止默认事件，如阻止<code>a</code>标签点击跳转</li><li><code>capture</code> 内部元素触发的事件先在此处理，然后才由内部元素进行处理</li><li><code>self</code> 将事件绑定在自身身上，相当于阻止事件冒泡</li><li><code>once</code> 事件只触发一次</li><li><code>passive</code> 阻止默认事件，能够提升移动端的性能。</li><li><code>native</code> 触发原生事件，而非自定义事件</li></ul></li><li><p>鼠标按键修饰符</p><ul><li><code>left</code> 鼠标左键</li><li><code>right</code> 鼠标右键</li><li><code>middle</code> 鼠标中键</li></ul></li><li><p>键盘修饰符 (部分举例)</p><ul><li><code>enter</code> 回车</li><li><code>esc</code> 退出</li></ul></li><li><p>v-bind 修饰符</p><ul><li><code>sync</code> 双向绑定</li><li><code>camel</code> 由于绑定特性时，会将大写字母转换为小写字母，得到不是一个驼峰属性，使用 camel 修饰符可以将 v-bind 属性名称驼峰化</li><li><code>prop</code> 被加入此修饰符的属性不会被渲染到最终的<code>dom</code>结构上</li></ul></li><li><p>系统修饰符</p><ul><li><p><code>ctrl</code></p></li><li><p><code>alt</code></p></li><li><p><code>shift</code></p></li><li><p><code>meta</code></p></li><li><p><code>exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.ctrl</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.ctrl.exact</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onCtrlClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ol><h2 id="_4、vue-挂载实例的过程" tabindex="-1"><a class="header-anchor" href="#_4、vue-挂载实例的过程" aria-hidden="true">#</a> 4、vue 挂载实例的过程</h2><ul><li><code>new Vue</code>的时候调用会调用<code>_init</code>方法 <ul><li>定义 <code>$set</code>、<code>$get </code>、<code>$delete</code>、<code>$watch</code> 等方法</li><li>定义 <code>$on</code>、<code>$off</code>、<code>$emit</code>、<code>$off</code>等事件</li><li>定义 <code>_update</code>、<code>$forceUpdate</code>、<code>$destroy</code>生命周期</li></ul></li><li>调用<code>$mount</code>进行页面的挂载</li><li>挂载的时候主要是通过<code>mountComponent</code>方法</li><li>定义<code>updateComponent</code>更新函数</li><li>执行<code>render</code>生成虚拟<code>DOM</code></li><li><code>_update</code>将虚拟<code>DOM</code>生成真实<code>DOM</code>结构，并且渲染到页面中</li></ul><h2 id="_5、首屏加载慢的解决方案" tabindex="-1"><a class="header-anchor" href="#_5、首屏加载慢的解决方案" aria-hidden="true">#</a> 5、首屏加载慢的解决方案</h2><ul><li>减小入口文件体积</li><li>静态资源本地缓存</li><li><code>UI</code>框架按需加载</li><li>图片资源压缩</li><li>减少组件重复打包</li><li>开启<code>Gzip</code>压缩（需要服务端做支持）</li><li>使用<code>SSR</code></li></ul><h2 id="_6、为什么-vue3-中要使用proxy" tabindex="-1"><a class="header-anchor" href="#_6、为什么-vue3-中要使用proxy" aria-hidden="true">#</a> 6、为什么 <code>vue3</code> 中要使用<code>Proxy</code></h2><ul><li>在 <code>vue2</code> 中使用的是<code>Object.defineProperty</code>,但是这个 <code>api</code> 不能监听对象属性的新增和删除，为此在 <code>vue2</code> 中引入了<code>Vue.set</code>和<code>Vue.delete</code>方法，但是 <code>proxy</code> 可以解决这个问题，并且可以监听到对象的新增和删除，所以<code>vue3</code> 中使用<code>Proxy</code></li><li><code>Object.defineProperty</code>监听深层次的属性变化是需要递归监听对象的属性，这种方式会导致对嵌套对象的监听变得复杂而且低效，<code>proxy</code>能够对整个对象进行监听，只需要递归监听对象即可。</li><li><code>proxy</code>能监听整个数组的变化</li></ul>`,13)])])}const s=o(l,[["render",n],["__file","vue.html.vue"]]);export{s as default};
